#include <iostream>
#include <string>
#include <cctype>
#include <vector>
#include <sstream>
#include <algorithm>

// ————————————
// Вспомогательные функции
// ————————————

static bool isHexDigit(char c) {
    c = std::tolower(c);
    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');
}

// Парсинг целого числа из строки [pos..end), возвращает -1 при ошибке
static int parseInt(const std::string& s, size_t pos, size_t len) {
    if (len == 0) return -1;
    int val = 0;
    for (size_t i = 0; i < len; ++i) {
        char c = s[pos + i];
        if (!std::isdigit(c)) return -1;
        val = val * 10 + (c - '0');
    }
    return val;
}

// Парсинг процента: строка должна заканчиваться на '%', число 0–100
static bool parsePercent(const std::string& token, int& out) {
    if (token.empty() || token.back() != '%') return false;
    int v = parseInt(token, 0, token.size()-1);
    if (v < 0 || v > 100) return false;
    out = v;
    return true;
}

// Разбивает s по всем символам из delims, но сохраняет непустые токены
static std::vector<std::string> split(const std::string& s, const std::string& delims) {
    std::vector<std::string> res;
    size_t i = 0, n = s.size();
    while (i < n) {
        // пропускаем разделители
        while (i<n && delims.find(s[i]) != std::string::npos) ++i;
        if (i>=n) break;
        size_t j = i;
        while (j<n && delims.find(s[j]) == std::string::npos) ++j;
        res.emplace_back(s.substr(i, j-i));
        i = j;
    }
    return res;
}

// Case-insensitive сравнение
static bool iequals(const std::string& a, const std::string& b) {
    if (a.size() != b.size()) return false;
    for (size_t i=0; i<a.size(); ++i)
        if (std::tolower(a[i]) != std::tolower(b[i])) return false;
    return true;
}

// ————————————
// Проверка web-цвета
// ————————————
bool isValidWebColor(const std::string& raw) {
    // удалим по краям пробелы
    size_t b = 0, e = raw.size();
    while (b<e && std::isspace(raw[b])) ++b;
    while (e>b && std::isspace(raw[e-1])) --e;
    if (e-b < 4) return false;
    std::string s = raw.substr(b, e-b);

    // HEX: #rgb или #rrggbb
    if (s[0]=='#') {
        size_t L = s.size();
        if (L==4) {
            // проверяем, что три символа — hex
            return isHexDigit(s[1]) && isHexDigit(s[2]) && isHexDigit(s[3]);
        }
        if (L==7) {
            for (int i=1; i<7; ++i)
                if (!isHexDigit(s[i])) return false;
            return true;
        }
        return false;
    }

    // rgb(...) или hsl(...)
    // найдем имя до '('
    auto p = s.find('(');
    auto q = s.rfind(')');
    if (p==std::string::npos || q==std::string::npos || q<=p) return false;
    std::string name = s.substr(0, p);
    std::string inside = s.substr(p+1, q-p-1);
    // разобьём по запятым
    auto parts = split(inside, ",");
    if (iequals(name,"rgb")) {
        if (parts.size() != 3) return false;
        for (auto& t : parts) {
            // удалим пробелы
            size_t u=0, v=t.size();
            while (u<v && std::isspace(t[u])) ++u;
            while (v>u && std::isspace(t[v-1])) --v;
            std::string tok = t.substr(u, v-u);
            if (tok.empty()) return false;
            int val;
            if (tok.back()=='%') {
                if (!parsePercent(tok,val)) return false;
            } else {
                val = parseInt(tok,0,tok.size());
                if (val<0 || val>255) return false;
            }
        }
        return true;
    }
    if (iequals(name,"hsl")) {
        if (parts.size() != 3) return false;
        // первый — угол 0–360
        {
            std::string t = parts[0];
            int u=0, v=t.size();
            while (u<v && std::isspace(t[u])) ++u;
            while (v>u && std::isspace(t[v-1])) --v;
            int h = parseInt(t,u,v-u);
            if (h<0 || h>360) return false;
        }
        // два следующих — проценты 0–100%
        for (int i=1; i<3; ++i) {
            int val;
            if (!parsePercent(parts[i], val)) return false;
        }
        return true;
    }

    return false;
}

// ————————————
// Проверка даты
// ————————————
bool isValidDate(const std::string& raw) {
    // обрезаем пробелы
    size_t b=0, e=raw.size();
    while (b<e && std::isspace(raw[b])) ++b;
    while (e>b && std::isspace(raw[e-1])) --e;
    std::string s = raw.substr(b, e-b);
    if (s.empty()) return false;

    // 1) Numeric форматы: dd.mm.yyyy / dd/mm/yyyy / dd-mm-yyyy 
    //    yyyy.mm.dd и пр.
    static const std::string delims = "./-";
    auto tok = split(s, delims);
    if (tok.size()==3) {
        // если первый токен содержит только цифры и длина ==4, возможно "yyyy"
        bool firstIsYear = (tok[0].size()==4 && parseInt(tok[0],0,4)>=0);
        bool thirdIsYear = (tok[2].size()==4 && parseInt(tok[2],0,4)>=0);
        if ((firstIsYear && !thirdIsYear) || (!firstIsYear && thirdIsYear)) {
            // один из концов — год
            int day, mon, year;
            if (firstIsYear) {
                year = parseInt(tok[0],0,tok[0].size());
                mon  = parseInt(tok[1],0,tok[1].size());
                day  = parseInt(tok[2],0,tok[2].size());
            } else {
                day  = parseInt(tok[0],0,tok[0].size());
                mon  = parseInt(tok[1],0,tok[1].size());
                year = parseInt(tok[2],0,tok[2].size());
            }
            if (day<1 || day>31 || mon<1 || mon>12 || year<0) return false;
            // Упрощённо: не проверяем число дней в месяце
            return true;
        }
    }

    // 2) Русский формат: "14 января 1806"
    //    split по пробелу, должно быть 3 токена
    auto w = split(s, " ,");
    if (w.size()==3) {
        int day = parseInt(w[0],0,w[0].size());
        int year = parseInt(w[2],0,w[2].size());
        if (day<1 || day>31 || year<0) return false;
        static const std::vector<std::string> rus = {
            "января","февраля","марта","апреля","мая","июня",
            "июля","августа","сентября","октября","ноября","декабря"
        };
        for (auto& m : rus)
            if (iequals(w[1], m))
                return true;
    }

    // 3) Английский: "July 25, 1924" или "Sep 14, 1995"
    //    split на слово, число, число
    if (w.size()==3 && w[1].back()==',') {
        std::string month = w[0];
        month.pop_back(); // нет, в этом варианте month без запятой, а w[1] содержит запятую
        // на деле: w[1] = "25,", w[2] = "1924"
        int day = parseInt(w[1], 0, w[1].size()-1);
        int year = parseInt(w[2], 0, w[2].size());
        if (day<1 || day>31 || year<0) return false;
        static const std::vector<std::string> engFull = {
            "January","February","March","April","May","June",
            "July","August","September","October","November","December"
        };
        static const std::vector<std::string> engAbbr = {
            "Jan","Feb","Mar","Apr","May","Jun",
            "Jul","Aug","Sep","Oct","Nov","Dec"
        };
        for (auto& m : engFull) if (iequals(month,m)) return true;
        for (auto& m : engAbbr) if (iequals(month,m)) return true;
    }

    return false;
}

// ————————————
// main()
// ————————————
int main() {
    std::string line;

    std::cout << "Введите web-цвет: ";
    std::getline(std::cin, line);
    std::cout << (isValidWebColor(line) ? "OK\n" : "FAIL\n");

    std::cout << "Введите дату: ";
    std::getline(std::cin, line);
    std::cout << (isValidDate(line) ? "OK\n" : "FAIL\n");

    return 0;
}
